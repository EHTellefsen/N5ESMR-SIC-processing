# --Build in--
import os
import datetime

# --Proprietary--

# --Third Party--
import numpy as np
import xarray as xr
import uuid


def makeNetCDF(data_vars, date, hemisphere, area_def, save_dir):
    
    year = date[:4]
    month = date[5:7]
    day = date[8:10]

    # specifying outfile name and path
    ncfile_n = ("ESACCI-SEAICE-L3C-SICONC-NIMBUS5_ESMR-EASE2_%sH-%s%s%s-fv1.0.nc" % (hemisphere, year, month, day))
    ncfile_path = os.path.join(save_dir, ncfile_n)

    # convert to percentage
    data_vars['ice_conc'] *= 100
    data_vars['smearing_standard_error']*=100
    data_vars['algorithm_standard_error']*=100
    data_vars['total_standard_error']*=100
    data_vars['raw_ice_conc_values']*=100
    
    # Transform data_vars to netCDF suitable format
    area_shape = area_def.shape[0]
    for var in data_vars.keys():
        data_vars[var] = (["time","yc","xc"], data_vars[var].reshape((1,area_shape,area_shape)))
    
    # defining time and grid
    time_bnds_ = np.array([[datetime.datetime(int(year), int(month), int(day), 0, 0), datetime.datetime(int(year), int(month), int(day), 0, 0)+datetime.timedelta(days=1)]]).astype('datetime64[ns]')
    data_vars['Lambert_Azimuthal_Grid'] = (np.array(-2147483647))
    data_vars['time_bnds'] = (["time","nv"],time_bnds_)
    
    #meta data
    lonss, latss = area_def.get_lonlats()
    today = datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
    today_date = datetime.datetime.now().strftime("%Y-%m-%d")
    trackid = uuid.uuid4()

    # coordinate data
    coords = dict(
        time=[np.array(year+'-'+month+'-'+day+'T12:00:00.000000000').astype('datetime64[ns]')],
        xc = area_def.projection_x_coords/1000,
        yc = area_def.projection_y_coords/1000,
        lat=(["yc", "xc"], latss.astype(np.float32)),
        lon=(["yc", "xc"], lonss.astype(np.float32)),
    )

    #attributes
    attrs=dict(
        description="Weather related data.",
        title = 'Sea Ice Concentration Climate Data Record from ESA Climate Change Initiative',
        summary = 'This climate data record of sea ice concentration is obtained from passive microwave satellite data over the polar regions (ESMR). The processing chain features: 1) dynamic tuning of tie-points and algorithms,  2) correction of atmospheric noise using a Radiative Transfer Model,  3) computation of per-pixel uncertainties, and 4) one channel sea ice concentration algorithm. This dataset was generated by the ESA Climate Change Initiative.',
        opiccategory = 'Oceans Climatology Meteorology Atmosphere',
        keywords = 'Earth Science > Cryosphere > Sea Ice > Sea Ice Concentration\nEarth Science > Oceans > Sea Ice > Sea Ice Concentration\nEarth Science > Climate Indicators > Cryospheric Indicators > Sea Ice Concentration',
        keywords_vocabulary = 'GCMD Science Keywords',
        geospatial_lat_min = np.min(latss),
        geospatial_lat_max =np.max(latss),
        geospatial_lon_min = np.min(lonss),
        geospatial_lon_max = np.max(lonss),
        geospatial_vertical_min = 0.0,
        geospatial_vertical_max = 0.0,
        sensor = 'ESMR',
        platform = 'Nimbus-5',
        source = 'ESMR from Nimbus 5,ERA-5 fields from ECMWF', # TO BE CHANGED
        time_coverage_start = '1972-12-11T00:00:00Z',
        time_coverage_end = '1977-05-16T23:59:59Z',
        time_coverage_duration = 'P1D',
        time_coverage_resolution = 'P1D', #?
        project = 'ESA Climate Change Initiative',
        institution =  'ESA Climate Change Initiative',
        creator_name = 'DTU Space',
        creator_type = 'University', # TO BE CHANGED
        creator_url = 'https://www.space.dtu.dk/',
        # creator_email =  '', # TO BE CHANGED
        license =  "All intellectual property rights of the ESA Climate Change Initiative products belong to ESA. The use of these products is granted to every user, free of charge. If users wish to use these products, ESA's copyright credit must be shown by displaying the words 'Copyright ESA' under each of the products shown. ESA offers no warranty and accepts no liability. ESA neither commits to nor guarantees the continuity, availability, or quality or suitability for any purpose.",
        # LICENSE NEEDS TO BE CHANGED
        references =  'https://climate.esa.int/en/projects/sea-ice/Sea-Ice-Key-Documents/', #TO BE CHANGED
        history =  ('%sZ creation' % (today)), #'2021-11-10T14:00:00Z creation',
        date_created = ('%s' % (today_date)), #'2021-10-11',
        cdm_data_type = 'Grid',
        spatial_resolution = '25.0 km grid spacing',
        algorithm = 'ESMR',
        geospatial_bounds_crs = 'EPSG:6931',
        contributor_name = 'Rasmus Tonboe, Wiebke Margitta Kolbe, Leif Toudal Pedersen, Thomas Lavergne, Atle Soerensen, Roberto Saldo, Emil Haaber Tellefsen', # TO BE CHANGED
        contributor_role =  'PrincipalInvestigator, Co-Investigator, author,author,author,author,author',
        product_version =  '1.1',
        tracking_id = '%s' % (trackid) ,# '1b406bc7-3879-43cf-ba8b-d6d35f5e254d', #?
        naming_authority =  'esa.int', #TO BE CHANGED
        Conventions =  'CF-1.6 ACDD-1.3',
        standard_name_vocabulary =  'Using Standard Name Table Version 78 (2021-09-21T11:55:06Z)'
        )
    
    #creating xarray
    dNN = xr.Dataset(data_vars, coords, attrs)
    
    
    #Set attributes to variables
    #time
    dNN.time.attrs['long_name'] = "reference time of product"
    dNN.time.attrs['standard_name'] = "time"
    dNN.time.attrs['axis'] = "T"
    dNN.time.attrs['bounds'] = "time_bnds"
    dNN.time.encoding['units'] = "days since "+'1900'+'-'+'01'+'-'+'01'+'T12:00:00.000000000'
##    dNN.time.encoding['units'] = "days since "+aar+'-'+maaned+'-'+dag+'T12:00:00.000000000'

##    dNN.time_bnds.encoding['units'] = "days since "+aar+'-'+maaned+'-'+dag+'T12:00:00.000000000'
    dNN.time_bnds.encoding['units'] = "days since "+'1900'+'-'+'01'+'-'+'01'+'T12:00:00.000000000'

    #lon
    dNN.lon.attrs['units'] = "degrees_east"
    dNN.lon.attrs['long_name'] = "longitude coordinate"
    dNN.lon.attrs['standard_name'] = "longitude"

    #lat
    dNN.lat.attrs['units'] = "degrees_north"
    dNN.lat.attrs['long_name'] = "latitude coordinate"
    dNN.lat.attrs['standard_name'] = "latitude"

    #xc
    dNN.xc.attrs['units'] = "km"
    dNN.xc.attrs['long_name'] = "x coordinate of projection (eastings)"
    dNN.xc.attrs['standard_name'] = "projection_x_coordinate"

    #yc
    dNN.yc.attrs['units'] = "km"
    dNN.yc.attrs['long_name'] = "y coordinate of projection (northings)"
    dNN.yc.attrs['standard_name'] = "projection_y_coordinate"

    #Lambert_Azimuthal_Grid
    dNN.Lambert_Azimuthal_Grid.attrs['grid_mapping_name'] = "lambert_azimuthal_equal_area"
    dNN.Lambert_Azimuthal_Grid.attrs['longitude_of_projection_origin']  = int(area_def.proj_dict['lon_0'])
    dNN.Lambert_Azimuthal_Grid.attrs['latitude_of_projection_origin']  = int(area_def.proj_dict['lat_0'])
    dNN.Lambert_Azimuthal_Grid.attrs['semi_major_axis']  = 6378137 
    dNN.Lambert_Azimuthal_Grid.attrs['semi_minor_axis']  = 6356752.314245 
    dNN.Lambert_Azimuthal_Grid.attrs['inverse_flattening']  = 298.257223563 
    dNN.Lambert_Azimuthal_Grid.attrs['proj4_string'] = area_def.proj_str

    #ice_conc
    dNN.ice_conc.attrs['long_name'] = 'fully filtered concentration of sea ice using atmospheric correction of brightness temperatures and open water filters'
    dNN.ice_conc.attrs['standard_name'] = 'sea_ice_area_fraction'
    dNN.ice_conc.attrs['units'] = '%'
    dNN.ice_conc.attrs['valid_min'] = 0
    dNN.ice_conc.attrs['valid_max'] = 100
    dNN.ice_conc.attrs['grid_mapping'] = 'Lambert_Azimuthal_Grid'
    dNN.ice_conc.attrs['ancillary_variables'] = 'total_standard_error status_flag'
    dNN.ice_conc.attrs['comment'] = 'this field is the primary sea ice concentration estimate for this climate data record'

    # raw_ice_conc_values
    dNN.raw_ice_conc_values.attrs['long_name'] = 'sea ice concentration estimates as retrieved by the algorithm, and that were edited away by the various filters'
    dNN.raw_ice_conc_values.attrs['units'] = '%'
    dNN.raw_ice_conc_values.attrs['grid_mapping'] = 'Lambert_Azimuthal_Grid'
    dNN.raw_ice_conc_values.attrs['comment'] = 'this field can be used in combination with "ice_conc" to access un-bounded normal distribution of sea ice concentration estimates corresponding to the uncertainty estimate in "total_standard_error". It does also feature some amount of un-physical data (below 0 and above 1).'
    
    #total_standard_error
    dNN.total_standard_error.attrs['long_name'] = 'total uncertainty (one standard deviation) of concentration of sea ice'
    dNN.total_standard_error.attrs['standard_name'] = 'sea_ice_area_fraction standard_error'
    dNN.total_standard_error.attrs['units'] =  '%'
    dNN.total_standard_error.attrs['grid_mapping'] = 'Lambert_Azimuthal_Grid'

    #smearing_standard_error
    dNN.smearing_standard_error.attrs['long_name'] = 'smearing uncertainty (one standard deviation) of concentration of sea ice'
    dNN.smearing_standard_error.attrs['units'] = '%'
    dNN.smearing_standard_error.attrs['grid_mapping'] = 'Lambert_Azimuthal_Grid'
    dNN.smearing_standard_error.attrs['comment'] = "this is one of the two components contributing to 'total_standard_error'"

    #algorithm_standard_error
    dNN.algorithm_standard_error.attrs['long_name'] = 'algorithm uncertainty (one standard deviation) of concentration of sea ice'
    dNN.algorithm_standard_error.attrs['units'] = '%'
    dNN.algorithm_standard_error.attrs['grid_mapping'] = 'Lambert_Azimuthal_Grid'
    dNN.algorithm_standard_error.attrs['comment'] = "this is one of the two components contributing to 'total_standard_error'"

    #status_flag
    dNN.status_flag.attrs['long_name'] = 'status flag bit array for sea ice concentration retrievals',
    dNN.status_flag.attrs['standard_name'] = 'sea_ice_area_fraction status_flag',
    dNN.status_flag.attrs['_FillValue'] = 0,
    dNN.status_flag.attrs['valid_min'] = 1,
    dNN.status_flag.attrs['valid_max'] = 32767, #???
    dNN.status_flag.attrs['grid_mapping'] = 'Lambert_Azimuthal_Grid',
    dNN.status_flag.attrs['flag_masks'] = np.array([ 1,2,4,8,16,32,64,128]).astype('int32')
    dNN.status_flag.attrs['flag_meanings'] = 'land lake open_water_filtered land_spill_over high_t2m coast max_ice_climo not_accepted', #check
    dNN.status_flag.attrs['flag_descriptions'] = '\nall bits to 0 (no flag/flag 0): Nominal retrieval by the SIC algorithm\nbit 1 (flag 1): Position is over land\nbit 2 (flag 2): Position is lake\nbit 3 (flag 4): SIC is set to zero by the open water filter\nbit 4 (flag 8): SIC value is changed for correcting land spill-over effects\nbit 5 (flag 16): Handle with caution, the 2m air temperature is high at this position, and this might be false ice\nbit 6 (flag 32): Coast\nbit 7 (flag 64):  SIC is set to zero since position is outside maximum sea ice climatology \nbit 8 (flag 128): Point not accepted but no other flags raised.',
    dNN.status_flag.attrs['comment'] = 'Flag values found in the map might be combinations of those listed above. For example flag value 80 (= 2^4 + 2^6 = 16 + 64) indicates high_t2m AND temporal_interp'
    
    #Tb_corr
    dNN.Tb_corr.attrs['long_name'] = 'corrected brightness temperatures'
    #dNN.Tb_corr.attrs['standard_name'] = 'brightness_temperature_corrected'
    dNN.Tb_corr.attrs['units'] = 'K'
    dNN.Tb_corr.attrs['valid_min'] = 90
    dNN.Tb_corr.attrs['valid_max'] = 273.15
    dNN.Tb_corr.attrs['grid_mapping'] = 'Lambert_Azimuthal_Grid'
    dNN.Tb_corr.attrs['comment'] = 'these are the corrected brightness temperatures'
    
    #Tb
    dNN.Tb.attrs['long_name'] = '(uncorrected) brightness temperatures'
    #dNN.Tb.attrs['standard_name'] = 'brightness_temperature'
    dNN.Tb.attrs['units'] = 'K'
    dNN.Tb.attrs['valid_min'] = 90
    dNN.Tb.attrs['valid_max'] = 273.15
    dNN.Tb.attrs['grid_mapping'] = 'Lambert_Azimuthal_Grid'
    dNN.Tb.attrs['comment'] = 'these are the uncorrected brightness temperatures'
    
    #save to netcdf
    dNN.to_netcdf(path=ncfile_path, mode ='w',format='NETCDF4_CLASSIC',encoding = {'time_bnds': {'_FillValue': None},"ice_conc": {"zlib": True},"raw_ice_conc_values": {"zlib": True},"total_standard_error": {"zlib": True},"smearing_standard_error": {"zlib": True},"algorithm_standard_error": {"zlib": True},"Tb_corr": {"zlib": True},"Tb": {"zlib": True}},unlimited_dims={'time':True})
